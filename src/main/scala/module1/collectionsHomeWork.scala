package module1

import scala.util.Random


class ProbabilityExperiment(var bucket: List[Int]) {


  //  def this() = this(rec())


  def get(): Int = {
    val randomIndex = Random.nextInt(bucket.length)
    //    println(s"Index: $randomIndex")
    val res = bucket(randomIndex)
    bucket = bucket.zipWithIndex.filter(_._2 != randomIndex).map(_._1)
    res
  }

  def takeTwo(): Boolean = (get(), get()) match {
    case (0, 1) => true
    case _ => false
  }

  override def toString: String = bucket.mkString(";")
}

//Если кратко:
//  В урне 3 белых и 3 черных шара. Из урны дважды вынимают по одному шару, не возвращая их обратно. Найти вероятность появления белого шара при втором испытании (событие В), если при первом испытании был извлечен черный шар (событие А).
//  Как будем делать:
//
//  создать класс с моделированием эксперимента, в нем должна быть коллекция (List) моделирующая урну с шариками (1 - белый шарик, 0 - черный шарик) и функция случайного выбора 2х шариков без возвращения (scala.util.Random),
//  возвращать эта функция должна true (если первый шарик был черный, а второй белый) и false (в противном случае)
//  создать коллекцию обьектов этих классов, скажем 10000 элементов, и провести этот эксперимент (функция map)
//  посчитать количество элементов массива из пункта 2 где функция вернула true, это количество поделенное на общее количество элементов массива и даст условную вероятность, которая должна быть около 3/5
//  PS: чем больше будет количество опытов в пункте 2, тем ближе будет результат моделирования к аналитическому решению
//
//  Критерии оценки:
//  Результат должен быть близок к ожидаемому
//  Использовать как можно меньше явных циклов, отдавая предпочтение высокоуровневым функциям, как то map, foreach, fold, filter
//  Используйте только стандартные библиотеки из базового набора
object ProbabilityExperiment {
  def run(): Unit = {

    val iterationsCount = 100000

    val successCount = (1 to iterationsCount).count(_ => new ProbabilityExperiment(List(1, 0, 1, 0, 1, 0)).takeTwo()).toDouble

    println(successCount / iterationsCount)

    // Честно говоря не очень понял почему в задании сказано что должно получиться 3/5.
    // Ведь условная вероятность это произведение P(AB)=P(A)*P(B|A); P(AB)=1/2*3/5=3/10
    //


  }
}